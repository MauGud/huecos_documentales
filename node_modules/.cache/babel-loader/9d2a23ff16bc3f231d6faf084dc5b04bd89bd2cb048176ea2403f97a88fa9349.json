{"ast":null,"code":"import { MEXICAN_STATES } from '../constants/documentTypes';\nexport class DocumentGapAnalyzer {\n  /**\n   * REGLA 1: Detección de gaps por cambio de placas\n   * Si detecta placas diferentes en documentos, debe existir:\n   * - Documento de baja de placas anteriores\n   * - Documento de alta de placas nuevas\n   * - Fechas coherentes\n   * - Estado emisor debe cambiar apropiadamente\n   */\n  detectPlateChangeGaps(documents) {\n    const gaps = [];\n    const plateChanges = this.identifyPlateChanges(documents);\n    for (const change of plateChanges) {\n      const {\n        from,\n        to,\n        changeDate,\n        documents: relatedDocs\n      } = change;\n\n      // Verificar si existe baja de placas anteriores\n      const bajaExists = documents.some(doc => doc.type === 'baja_placas' && doc.plateNumber === from.plateNumber && doc.state === from.state && Math.abs(doc.issueDate.getTime() - changeDate.getTime()) <= 30 * 24 * 60 * 60 * 1000 // 30 días\n      );\n      if (!bajaExists) {\n        gaps.push({\n          id: `baja_placas_${from.plateNumber}_${changeDate.getTime()}`,\n          type: 'baja_placas',\n          expectedDateRange: {\n            from: new Date(changeDate.getTime() - 15 * 24 * 60 * 60 * 1000),\n            to: new Date(changeDate.getTime() + 15 * 24 * 60 * 60 * 1000)\n          },\n          reason: `Cambio de placas de ${from.plateNumber} (${from.state}) a ${to.plateNumber} (${to.state}) sin baja documentada`,\n          severity: 'critical',\n          relatedDocuments: relatedDocs.map(doc => doc.id),\n          suggestedAction: `Obtener constancia de baja de placas ${from.plateNumber} en ${MEXICAN_STATES[from.state].issuingAuthority}`,\n          estimatedCost: 500,\n          issuingAuthority: MEXICAN_STATES[from.state].issuingAuthority,\n          requiredDocuments: ['tarjeta_circulacion', 'tenencia', 'verificacion']\n        });\n      }\n\n      // Verificar si existe alta de placas nuevas\n      const altaExists = documents.some(doc => doc.type === 'alta_placas' && doc.plateNumber === to.plateNumber && doc.state === to.state && Math.abs(doc.issueDate.getTime() - changeDate.getTime()) <= 30 * 24 * 60 * 60 * 1000);\n      if (!altaExists) {\n        gaps.push({\n          id: `alta_placas_${to.plateNumber}_${changeDate.getTime()}`,\n          type: 'alta_placas',\n          expectedDateRange: {\n            from: new Date(changeDate.getTime() - 15 * 24 * 60 * 60 * 1000),\n            to: new Date(changeDate.getTime() + 15 * 24 * 60 * 60 * 1000)\n          },\n          reason: `Cambio de placas a ${to.plateNumber} (${to.state}) sin alta documentada`,\n          severity: 'high',\n          relatedDocuments: relatedDocs.map(doc => doc.id),\n          suggestedAction: `Solicitar copia de alta de placas ${to.plateNumber} en ${MEXICAN_STATES[to.state].issuingAuthority}`,\n          estimatedCost: 300,\n          issuingAuthority: MEXICAN_STATES[to.state].issuingAuthority,\n          requiredDocuments: ['factura_endosada', 'contrato_compraventa']\n        });\n      }\n    }\n    return gaps;\n  }\n\n  /**\n   * REGLA 2: Detección de gaps por cambio de propietario\n   * Por cada cambio de nombre detectado:\n   * - Debe existir factura endosada O refactura\n   * - Nueva tarjeta de circulación dentro de 15-30 días\n   * - Si cambió de estado, aplicar regla de placas\n   * - Contrato de compraventa debe estar presente\n   */\n  detectOwnershipGaps(documents) {\n    const gaps = [];\n    const ownershipChanges = this.identifyOwnershipChanges(documents);\n    for (const change of ownershipChanges) {\n      const {\n        from,\n        to,\n        changeDate,\n        documents: relatedDocs\n      } = change;\n\n      // Verificar factura endosada o refactura\n      const transferDocExists = documents.some(doc => (doc.type === 'factura_endosada' || doc.type === 'refactura') && doc.ownerName === to.ownerName && Math.abs(doc.issueDate.getTime() - changeDate.getTime()) <= 30 * 24 * 60 * 60 * 1000);\n      if (!transferDocExists) {\n        gaps.push({\n          id: `transfer_doc_${to.ownerName}_${changeDate.getTime()}`,\n          type: 'factura_endosada',\n          expectedDateRange: {\n            from: new Date(changeDate.getTime() - 15 * 24 * 60 * 60 * 1000),\n            to: new Date(changeDate.getTime() + 15 * 24 * 60 * 60 * 1000)\n          },\n          reason: `Cambio de propietario de \"${from.ownerName}\" a \"${to.ownerName}\" sin documento de transferencia`,\n          severity: 'critical',\n          relatedDocuments: relatedDocs.map(doc => doc.id),\n          suggestedAction: 'Obtener factura endosada o refactura que documente la transferencia',\n          estimatedCost: 800,\n          requiredDocuments: ['factura_origen', 'contrato_compraventa']\n        });\n      }\n\n      // Verificar nueva tarjeta de circulación\n      const newCirculationCard = documents.find(doc => doc.type === 'tarjeta_circulacion' && doc.ownerName === to.ownerName && Math.abs(doc.issueDate.getTime() - changeDate.getTime()) <= 30 * 24 * 60 * 60 * 1000);\n      if (!newCirculationCard) {\n        gaps.push({\n          id: `new_circulation_card_${to.ownerName}_${changeDate.getTime()}`,\n          type: 'tarjeta_circulacion',\n          expectedDateRange: {\n            from: new Date(changeDate.getTime() - 15 * 24 * 60 * 60 * 1000),\n            to: new Date(changeDate.getTime() + 15 * 24 * 60 * 60 * 1000)\n          },\n          reason: `Nuevo propietario \"${to.ownerName}\" sin tarjeta de circulación actualizada`,\n          severity: 'high',\n          relatedDocuments: relatedDocs.map(doc => doc.id),\n          suggestedAction: 'Actualizar tarjeta de circulación con datos del nuevo propietario',\n          estimatedCost: 400,\n          requiredDocuments: ['factura_endosada', 'alta_placas']\n        });\n      }\n\n      // Verificar contrato de compraventa\n      const contractExists = documents.some(doc => doc.type === 'contrato_compraventa' && doc.ownerName === to.ownerName && Math.abs(doc.issueDate.getTime() - changeDate.getTime()) <= 30 * 24 * 60 * 60 * 1000);\n      if (!contractExists) {\n        gaps.push({\n          id: `contract_${to.ownerName}_${changeDate.getTime()}`,\n          type: 'contrato_compraventa',\n          expectedDateRange: {\n            from: new Date(changeDate.getTime() - 15 * 24 * 60 * 60 * 1000),\n            to: new Date(changeDate.getTime() + 15 * 24 * 60 * 60 * 1000)\n          },\n          reason: `Transferencia de propiedad sin contrato de compraventa documentado`,\n          severity: 'medium',\n          relatedDocuments: relatedDocs.map(doc => doc.id),\n          suggestedAction: 'Obtener contrato de compraventa firmado por ambas partes',\n          estimatedCost: 200,\n          requiredDocuments: ['identificaciones', 'comprobantes_domicilio']\n        });\n      }\n    }\n    return gaps;\n  }\n\n  /**\n   * REGLA 3: Detección de gaps en pagos anuales obligatorios\n   * Para cada año desde la compra:\n   * - Debe existir tenencia O refrendo pagado\n   * - No puede haber años sin pago\n   * - Excepción: estados que condonaron el impuesto\n   * - Nombre en recibo debe coincidir con propietario del periodo\n   */\n  detectAnnualPaymentGaps(documents) {\n    const gaps = [];\n    const paymentYears = this.getPaymentYears(documents);\n    for (const year of paymentYears) {\n      const yearStart = new Date(year, 0, 1);\n      const yearEnd = new Date(year, 11, 31);\n\n      // Obtener propietario del año\n      const yearOwner = this.getOwnerForYear(documents, year);\n      if (!yearOwner) continue;\n\n      // Verificar si el estado tiene tenencia o refrendo\n      const state = yearOwner.state;\n      const stateConfig = MEXICAN_STATES[state];\n      if (!stateConfig.hasTenencia && !stateConfig.hasRefrendo) {\n        continue; // Estado que no requiere pago anual\n      }\n\n      // Buscar pago del año\n      const paymentExists = documents.some(doc => {\n        const docYear = doc.issueDate.getFullYear();\n        const isPaymentDoc = stateConfig.hasTenencia ? doc.type === 'tenencia' : doc.type === 'refrendo';\n        const isCorrectYear = docYear === year;\n        const isCorrectOwner = doc.ownerName === yearOwner.ownerName;\n        const isCorrectState = doc.state === state;\n        return isPaymentDoc && isCorrectYear && isCorrectOwner && isCorrectState;\n      });\n      if (!paymentExists) {\n        const paymentType = stateConfig.hasTenencia ? 'tenencia' : 'refrendo';\n        const paymentName = stateConfig.hasTenencia ? 'Tenencia' : 'Refrendo';\n        gaps.push({\n          id: `${paymentType}_${year}_${yearOwner.ownerName}`,\n          type: paymentType,\n          expectedDateRange: {\n            from: yearStart,\n            to: yearEnd\n          },\n          reason: `Falta pago de ${paymentName} ${year} para propietario \"${yearOwner.ownerName}\" en ${state}`,\n          severity: 'high',\n          relatedDocuments: [],\n          suggestedAction: `Pagar ${paymentName} ${year} en ${stateConfig.issuingAuthority}`,\n          estimatedCost: this.estimatePaymentCost(year, state),\n          issuingAuthority: stateConfig.issuingAuthority,\n          requiredDocuments: ['tarjeta_circulacion', 'verificacion']\n        });\n      }\n    }\n    return gaps;\n  }\n\n  /**\n   * REGLA 4: Detección de gaps en verificaciones vehiculares\n   * Según el estado (CDMX, EdoMex, etc):\n   * - Semestral: 2 verificaciones por año\n   * - Anual: 1 verificación por año\n   * - Placas deben coincidir con las del periodo\n   * - No gaps mayores a un periodo\n   */\n  detectVerificationGaps(documents) {\n    const gaps = [];\n    const verificationYears = this.getVerificationYears(documents);\n    for (const year of verificationYears) {\n      const yearStart = new Date(year, 0, 1);\n      const yearEnd = new Date(year, 11, 31);\n\n      // Obtener propietario y placas del año\n      const yearOwner = this.getOwnerForYear(documents, year);\n      if (!yearOwner) continue;\n      const state = yearOwner.state;\n      const stateConfig = MEXICAN_STATES[state];\n      const requiredVerifications = stateConfig.verificationFrequency === 'semiannual' ? 2 : 1;\n\n      // Buscar verificaciones del año\n      const verifications = documents.filter(doc => doc.type === 'verificacion' && doc.issueDate.getFullYear() === year && doc.ownerName === yearOwner.ownerName && doc.state === state);\n      if (verifications.length < requiredVerifications) {\n        const missing = requiredVerifications - verifications.length;\n        const frequency = stateConfig.verificationFrequency === 'semiannual' ? 'semestral' : 'anual';\n        gaps.push({\n          id: `verificacion_${year}_${yearOwner.ownerName}_${missing}`,\n          type: 'verificacion',\n          expectedDateRange: {\n            from: yearStart,\n            to: yearEnd\n          },\n          reason: `Faltan ${missing} verificación(es) ${frequency} ${year} para placas ${yearOwner.plateNumber || 'N/A'}`,\n          severity: 'medium',\n          relatedDocuments: verifications.map(doc => doc.id),\n          suggestedAction: `Realizar ${missing} verificación(es) vehicular(es) en ${stateConfig.issuingAuthority}`,\n          estimatedCost: missing * 200,\n          issuingAuthority: stateConfig.issuingAuthority,\n          requiredDocuments: ['tarjeta_circulacion', 'tenencia', 'refrendo']\n        });\n      }\n    }\n    return gaps;\n  }\n\n  /**\n   * REGLA 5: Validación de cadena de propiedad completa\n   * Desde factura origen hasta propietario actual:\n   * - Cada transferencia debe estar documentada\n   * - Secuencia: Factura origen → Endoso/Refactura → ... → Dueño actual\n   * - No puede haber saltos en la cadena\n   * - Fechas deben ser secuenciales\n   */\n  validateOwnershipChain(documents) {\n    const issues = [];\n    const ownershipChain = [];\n    const missingTransfers = [];\n\n    // Ordenar documentos por fecha\n    const sortedDocs = documents.filter(doc => ['factura_origen', 'factura_endosada', 'refactura'].includes(doc.type)).sort((a, b) => a.issueDate.getTime() - b.issueDate.getTime());\n    if (sortedDocs.length === 0) {\n      issues.push('No se encontraron documentos de propiedad');\n      return {\n        isValid: false,\n        issues,\n        ownershipChain,\n        missingTransfers\n      };\n    }\n\n    // Verificar factura origen\n    const facturaOrigen = sortedDocs.find(doc => doc.type === 'factura_origen');\n    if (!facturaOrigen) {\n      issues.push('Falta factura de origen del vehículo');\n    } else {\n      ownershipChain.push({\n        from: 'Concesionario',\n        to: facturaOrigen.ownerName,\n        transferDate: facturaOrigen.issueDate,\n        documentId: facturaOrigen.id\n      });\n    }\n\n    // Verificar transferencias secuenciales\n    let currentOwner = facturaOrigen === null || facturaOrigen === void 0 ? void 0 : facturaOrigen.ownerName;\n    for (let i = 1; i < sortedDocs.length; i++) {\n      const doc = sortedDocs[i];\n      const prevDoc = sortedDocs[i - 1];\n      if (doc.ownerName !== currentOwner) {\n        // Hay un cambio de propietario\n        ownershipChain.push({\n          from: currentOwner,\n          to: doc.ownerName,\n          transferDate: doc.issueDate,\n          documentId: doc.id\n        });\n\n        // Verificar que la fecha sea posterior a la anterior\n        if (doc.issueDate <= prevDoc.issueDate) {\n          issues.push(`Fecha de transferencia inválida: ${doc.issueDate.toISOString()} debe ser posterior a ${prevDoc.issueDate.toISOString()}`);\n        }\n        currentOwner = doc.ownerName;\n      }\n    }\n\n    // Verificar que no haya saltos en la cadena\n    const uniqueOwners = Array.from(new Set(sortedDocs.map(doc => doc.ownerName)));\n    if (uniqueOwners.length > 1) {\n      for (let i = 1; i < uniqueOwners.length; i++) {\n        const prevOwner = uniqueOwners[i - 1];\n        const currentOwner = uniqueOwners[i];\n        const hasTransfer = ownershipChain.some(transfer => transfer.from === prevOwner && transfer.to === currentOwner);\n        if (!hasTransfer) {\n          missingTransfers.push({\n            from: prevOwner,\n            to: currentOwner,\n            expectedDate: new Date(),\n            reason: 'Transferencia no documentada en la cadena de propiedad'\n          });\n          issues.push(`Falta documentación de transferencia de ${prevOwner} a ${currentOwner}`);\n        }\n      }\n    }\n    return {\n      isValid: issues.length === 0 && missingTransfers.length === 0,\n      issues,\n      ownershipChain,\n      missingTransfers\n    };\n  }\n\n  /**\n   * REGLA 6: Verificación de consistencia temporal\n   * Verificar que:\n   * - No hay documentos con fechas imposibles\n   * - Documentos del mismo periodo tienen mismo propietario\n   * - Multas corresponden al propietario del momento\n   * - Tarjeta de circulación vigente durante todo el periodo\n   */\n  checkTemporalConsistency(documents) {\n    const issues = [];\n\n    // Verificar fechas imposibles\n    const now = new Date();\n    const minDate = new Date(1900, 0, 1);\n    for (const doc of documents) {\n      if (doc.issueDate < minDate || doc.issueDate > now) {\n        issues.push({\n          id: `impossible_date_${doc.id}`,\n          type: 'impossible_date',\n          description: `Documento ${doc.type} tiene fecha imposible: ${doc.issueDate.toISOString()}`,\n          affectedDocuments: [doc.id],\n          severity: 'high',\n          suggestedFix: 'Verificar fecha de emisión del documento'\n        });\n      }\n    }\n\n    // Verificar consistencia de propietarios por periodo\n    const ownerConsistency = this.checkOwnerConsistency(documents);\n    issues.push(...ownerConsistency);\n\n    // Verificar tarjeta de circulación vigente\n    const circulationIssues = this.checkCirculationCardValidity(documents);\n    issues.push(...circulationIssues);\n    return issues;\n  }\n\n  /**\n   * Análisis completo de completitud de documentos\n   */\n  analyzeDocumentCompleteness(documents) {\n    // Aplicar todas las reglas\n    const plateGaps = this.detectPlateChangeGaps(documents);\n    const ownershipGaps = this.detectOwnershipGaps(documents);\n    const paymentGaps = this.detectAnnualPaymentGaps(documents);\n    const verificationGaps = this.detectVerificationGaps(documents);\n    const temporalIssues = this.checkTemporalConsistency(documents);\n    const ownershipValidation = this.validateOwnershipChain(documents);\n\n    // Combinar todos los gaps\n    const allGaps = [...plateGaps, ...ownershipGaps, ...paymentGaps, ...verificationGaps];\n\n    // Calcular score de completitud\n    const totalExpected = this.calculateExpectedDocuments(documents);\n    const presentDocuments = documents.length;\n    const completenessPercentage = totalExpected > 0 ? presentDocuments / totalExpected * 100 : 0;\n\n    // Calcular score (0-100)\n    let score = 100;\n    score -= plateGaps.filter(gap => gap.severity === 'critical').length * 20;\n    score -= plateGaps.filter(gap => gap.severity === 'high').length * 15;\n    score -= ownershipGaps.filter(gap => gap.severity === 'critical').length * 25;\n    score -= ownershipGaps.filter(gap => gap.severity === 'high').length * 20;\n    score -= paymentGaps.filter(gap => gap.severity === 'high').length * 10;\n    score -= verificationGaps.filter(gap => gap.severity === 'medium').length * 5;\n    score -= temporalIssues.filter(issue => issue.severity === 'critical').length * 15;\n    score = Math.max(0, Math.min(100, score));\n\n    // Determinar nivel de riesgo\n    let riskLevel = 'low';\n    if (score < 30) riskLevel = 'critical';else if (score < 50) riskLevel = 'high';else if (score < 70) riskLevel = 'medium';\n\n    // Generar recomendaciones\n    const recommendations = this.generateRecommendations(allGaps, temporalIssues, ownershipValidation);\n\n    // Agrupar gaps por severidad\n    const priorityActions = {\n      critical: allGaps.filter(gap => gap.severity === 'critical'),\n      high: allGaps.filter(gap => gap.severity === 'high'),\n      medium: allGaps.filter(gap => gap.severity === 'medium'),\n      low: allGaps.filter(gap => gap.severity === 'low')\n    };\n\n    // Calcular desglose por categoría\n    const categoryBreakdown = this.calculateCategoryBreakdown(documents, allGaps);\n    return {\n      score,\n      gaps: allGaps,\n      completenessPercentage,\n      criticalIssues: allGaps.filter(gap => gap.severity === 'critical').map(gap => gap.reason),\n      recommendations,\n      riskLevel,\n      temporalIssues,\n      ownershipValidation,\n      categoryBreakdown,\n      priorityActions\n    };\n  }\n\n  // Métodos auxiliares privados\n\n  identifyPlateChanges(documents) {\n    const changes = [];\n    const circulationCards = documents.filter(doc => doc.type === 'tarjeta_circulacion' && doc.plateNumber).sort((a, b) => a.issueDate.getTime() - b.issueDate.getTime());\n    for (let i = 1; i < circulationCards.length; i++) {\n      const prev = circulationCards[i - 1];\n      const curr = circulationCards[i];\n      if (prev.plateNumber !== curr.plateNumber || prev.state !== curr.state) {\n        changes.push({\n          from: {\n            plateNumber: prev.plateNumber,\n            state: prev.state\n          },\n          to: {\n            plateNumber: curr.plateNumber,\n            state: curr.state\n          },\n          changeDate: curr.issueDate,\n          documents: [prev, curr]\n        });\n      }\n    }\n    return changes;\n  }\n  identifyOwnershipChanges(documents) {\n    const changes = [];\n    const allDocs = documents.filter(doc => doc.ownerName).sort((a, b) => a.issueDate.getTime() - b.issueDate.getTime());\n    for (let i = 1; i < allDocs.length; i++) {\n      const prev = allDocs[i - 1];\n      const curr = allDocs[i];\n      if (prev.ownerName !== curr.ownerName) {\n        changes.push({\n          from: {\n            ownerName: prev.ownerName\n          },\n          to: {\n            ownerName: curr.ownerName\n          },\n          changeDate: curr.issueDate,\n          documents: [prev, curr]\n        });\n      }\n    }\n    return changes;\n  }\n  getPaymentYears(documents) {\n    const years = new Set();\n    const startYear = Math.min(...documents.map(doc => doc.issueDate.getFullYear()));\n    const currentYear = new Date().getFullYear();\n    for (let year = startYear; year <= currentYear; year++) {\n      years.add(year);\n    }\n    return Array.from(years);\n  }\n  getVerificationYears(documents) {\n    return this.getPaymentYears(documents);\n  }\n  getOwnerForYear(documents, year) {\n    const yearDocs = documents.filter(doc => doc.issueDate.getFullYear() === year);\n    if (yearDocs.length === 0) return null;\n\n    // Buscar el propietario más reciente del año\n    const latestDoc = yearDocs.sort((a, b) => b.issueDate.getTime() - a.issueDate.getTime())[0];\n    return {\n      ownerName: latestDoc.ownerName,\n      state: latestDoc.state,\n      plateNumber: latestDoc.plateNumber\n    };\n  }\n  estimatePaymentCost(year, state) {\n    // Estimación básica de costos por año y estado\n    const baseCost = 1000;\n    const yearMultiplier = Math.max(1, (new Date().getFullYear() - year) * 0.1);\n    return Math.round(baseCost * yearMultiplier);\n  }\n  checkOwnerConsistency(documents) {\n    const issues = [];\n    const ownerByPeriod = new Map();\n    for (const doc of documents) {\n      const period = `${doc.issueDate.getFullYear()}-${doc.issueDate.getMonth()}`;\n      const existingOwner = ownerByPeriod.get(period);\n      if (existingOwner && existingOwner !== doc.ownerName) {\n        issues.push({\n          id: `owner_mismatch_${period}`,\n          type: 'owner_mismatch',\n          description: `Inconsistencia de propietario en ${period}: ${existingOwner} vs ${doc.ownerName}`,\n          affectedDocuments: documents.filter(d => `${d.issueDate.getFullYear()}-${d.issueDate.getMonth()}` === period).map(d => d.id),\n          severity: 'medium',\n          suggestedFix: 'Verificar propietario correcto para el periodo'\n        });\n      } else {\n        ownerByPeriod.set(period, doc.ownerName);\n      }\n    }\n    return issues;\n  }\n  checkCirculationCardValidity(documents) {\n    const issues = [];\n    const circulationCards = documents.filter(doc => doc.type === 'tarjeta_circulacion').sort((a, b) => a.issueDate.getTime() - b.issueDate.getTime());\n    for (let i = 1; i < circulationCards.length; i++) {\n      const prev = circulationCards[i - 1];\n      const curr = circulationCards[i];\n      const gapDays = (curr.issueDate.getTime() - prev.issueDate.getTime()) / (1000 * 60 * 60 * 24);\n      if (gapDays > 30) {\n        issues.push({\n          id: `circulation_gap_${prev.id}_${curr.id}`,\n          type: 'impossible_date',\n          description: `Gap de ${Math.round(gapDays)} días entre tarjetas de circulación`,\n          affectedDocuments: [prev.id, curr.id],\n          severity: 'medium',\n          suggestedFix: 'Verificar si falta documentación intermedia'\n        });\n      }\n    }\n    return issues;\n  }\n  calculateExpectedDocuments(documents) {\n    // Cálculo básico de documentos esperados\n    const years = this.getPaymentYears(documents);\n    let expected = 1; // Factura origen\n\n    // Agregar documentos por año\n    years.forEach(year => {\n      expected += 1; // Tenencia o refrendo\n      expected += 1; // Verificación\n    });\n\n    // Agregar documentos de transferencia\n    const ownershipChanges = this.identifyOwnershipChanges(documents);\n    expected += ownershipChanges.length * 2; // Endoso + nueva tarjeta\n\n    return expected;\n  }\n  generateRecommendations(gaps, temporalIssues, ownershipValidation) {\n    const recommendations = [];\n    if (gaps.filter(gap => gap.severity === 'critical').length > 0) {\n      recommendations.push('1. URGENTE: Resolver gaps críticos de documentación');\n    }\n    if (ownershipValidation.missingTransfers.length > 0) {\n      recommendations.push('2. Completar cadena de propiedad faltante');\n    }\n    if (gaps.filter(gap => gap.type === 'tenencia' || gap.type === 'refrendo').length > 0) {\n      recommendations.push('3. Regularizar pagos anuales pendientes');\n    }\n    if (gaps.filter(gap => gap.type === 'verificacion').length > 0) {\n      recommendations.push('4. Realizar verificaciones vehiculares faltantes');\n    }\n    if (temporalIssues.length > 0) {\n      recommendations.push('5. Corregir inconsistencias temporales');\n    }\n    return recommendations;\n  }\n  calculateCategoryBreakdown(documents, gaps) {\n    const ownership = {\n      present: documents.filter(doc => ['factura_origen', 'factura_endosada', 'refactura'].includes(doc.type)).length,\n      expected: 1 + gaps.filter(gap => ['factura_endosada', 'refactura'].includes(gap.type)).length,\n      percentage: 0\n    };\n    const fiscal = {\n      present: documents.filter(doc => ['tenencia', 'refrendo'].includes(doc.type)).length,\n      expected: documents.filter(doc => ['tenencia', 'refrendo'].includes(doc.type)).length + gaps.filter(gap => ['tenencia', 'refrendo'].includes(gap.type)).length,\n      percentage: 0\n    };\n    const registration = {\n      present: documents.filter(doc => ['alta_placas', 'baja_placas', 'tarjeta_circulacion'].includes(doc.type)).length,\n      expected: documents.filter(doc => ['alta_placas', 'baja_placas', 'tarjeta_circulacion'].includes(doc.type)).length + gaps.filter(gap => ['alta_placas', 'baja_placas', 'tarjeta_circulacion'].includes(gap.type)).length,\n      percentage: 0\n    };\n    const verification = {\n      present: documents.filter(doc => doc.type === 'verificacion').length,\n      expected: documents.filter(doc => doc.type === 'verificacion').length + gaps.filter(gap => gap.type === 'verificacion').length,\n      percentage: 0\n    };\n\n    // Calcular porcentajes\n    ownership.percentage = ownership.expected > 0 ? ownership.present / ownership.expected * 100 : 100;\n    fiscal.percentage = fiscal.expected > 0 ? fiscal.present / fiscal.expected * 100 : 100;\n    registration.percentage = registration.expected > 0 ? registration.present / registration.expected * 100 : 100;\n    verification.percentage = verification.expected > 0 ? verification.present / verification.expected * 100 : 100;\n    return {\n      ownership,\n      fiscal,\n      registration,\n      verification\n    };\n  }\n}\nexport const documentGapAnalyzer = new DocumentGapAnalyzer();\nexport default documentGapAnalyzer;","map":{"version":3,"names":["MEXICAN_STATES","DocumentGapAnalyzer","detectPlateChangeGaps","documents","gaps","plateChanges","identifyPlateChanges","change","from","to","changeDate","relatedDocs","bajaExists","some","doc","type","plateNumber","state","Math","abs","issueDate","getTime","push","id","expectedDateRange","Date","reason","severity","relatedDocuments","map","suggestedAction","issuingAuthority","estimatedCost","requiredDocuments","altaExists","detectOwnershipGaps","ownershipChanges","identifyOwnershipChanges","transferDocExists","ownerName","newCirculationCard","find","contractExists","detectAnnualPaymentGaps","paymentYears","getPaymentYears","year","yearStart","yearEnd","yearOwner","getOwnerForYear","stateConfig","hasTenencia","hasRefrendo","paymentExists","docYear","getFullYear","isPaymentDoc","isCorrectYear","isCorrectOwner","isCorrectState","paymentType","paymentName","estimatePaymentCost","detectVerificationGaps","verificationYears","getVerificationYears","requiredVerifications","verificationFrequency","verifications","filter","length","missing","frequency","validateOwnershipChain","issues","ownershipChain","missingTransfers","sortedDocs","includes","sort","a","b","isValid","facturaOrigen","transferDate","documentId","currentOwner","i","prevDoc","toISOString","uniqueOwners","Array","Set","prevOwner","hasTransfer","transfer","expectedDate","checkTemporalConsistency","now","minDate","description","affectedDocuments","suggestedFix","ownerConsistency","checkOwnerConsistency","circulationIssues","checkCirculationCardValidity","analyzeDocumentCompleteness","plateGaps","ownershipGaps","paymentGaps","verificationGaps","temporalIssues","ownershipValidation","allGaps","totalExpected","calculateExpectedDocuments","presentDocuments","completenessPercentage","score","gap","issue","max","min","riskLevel","recommendations","generateRecommendations","priorityActions","critical","high","medium","low","categoryBreakdown","calculateCategoryBreakdown","criticalIssues","changes","circulationCards","prev","curr","allDocs","years","startYear","currentYear","add","yearDocs","latestDoc","baseCost","yearMultiplier","round","ownerByPeriod","Map","period","getMonth","existingOwner","get","d","set","gapDays","expected","forEach","ownership","present","percentage","fiscal","registration","verification","documentGapAnalyzer"],"sources":["/Users/maugudino/Desktop/Desarrollo/huecos_doc_v2/src/utils/documentGapAnalyzer.ts"],"sourcesContent":["import { \n  VehicleDocument, \n  DocumentGap, \n  DocumentType, \n  AnalysisResult, \n  TemporalIssue, \n  ValidationResult,\n  MexicanState \n} from '../types/documents';\nimport { MEXICAN_STATES } from '../constants/documentTypes';\n\nexport class DocumentGapAnalyzer {\n  \n  /**\n   * REGLA 1: Detección de gaps por cambio de placas\n   * Si detecta placas diferentes en documentos, debe existir:\n   * - Documento de baja de placas anteriores\n   * - Documento de alta de placas nuevas\n   * - Fechas coherentes\n   * - Estado emisor debe cambiar apropiadamente\n   */\n  detectPlateChangeGaps(documents: VehicleDocument[]): DocumentGap[] {\n    const gaps: DocumentGap[] = [];\n    const plateChanges = this.identifyPlateChanges(documents);\n\n    for (const change of plateChanges) {\n      const { from, to, changeDate, documents: relatedDocs } = change;\n\n      // Verificar si existe baja de placas anteriores\n      const bajaExists = documents.some(doc => \n        doc.type === 'baja_placas' &&\n        doc.plateNumber === from.plateNumber &&\n        doc.state === from.state &&\n        Math.abs(doc.issueDate.getTime() - changeDate.getTime()) <= 30 * 24 * 60 * 60 * 1000 // 30 días\n      );\n\n      if (!bajaExists) {\n        gaps.push({\n          id: `baja_placas_${from.plateNumber}_${changeDate.getTime()}`,\n          type: 'baja_placas',\n          expectedDateRange: {\n            from: new Date(changeDate.getTime() - 15 * 24 * 60 * 60 * 1000),\n            to: new Date(changeDate.getTime() + 15 * 24 * 60 * 60 * 1000)\n          },\n          reason: `Cambio de placas de ${from.plateNumber} (${from.state}) a ${to.plateNumber} (${to.state}) sin baja documentada`,\n          severity: 'critical',\n          relatedDocuments: relatedDocs.map((doc: any) => doc.id),\n          suggestedAction: `Obtener constancia de baja de placas ${from.plateNumber} en ${MEXICAN_STATES[from.state as keyof typeof MEXICAN_STATES].issuingAuthority}`,\n          estimatedCost: 500,\n          issuingAuthority: MEXICAN_STATES[from.state as keyof typeof MEXICAN_STATES].issuingAuthority,\n          requiredDocuments: ['tarjeta_circulacion', 'tenencia', 'verificacion']\n        });\n      }\n\n      // Verificar si existe alta de placas nuevas\n      const altaExists = documents.some(doc => \n        doc.type === 'alta_placas' &&\n        doc.plateNumber === to.plateNumber &&\n        doc.state === to.state &&\n        Math.abs(doc.issueDate.getTime() - changeDate.getTime()) <= 30 * 24 * 60 * 60 * 1000\n      );\n\n      if (!altaExists) {\n        gaps.push({\n          id: `alta_placas_${to.plateNumber}_${changeDate.getTime()}`,\n          type: 'alta_placas',\n          expectedDateRange: {\n            from: new Date(changeDate.getTime() - 15 * 24 * 60 * 60 * 1000),\n            to: new Date(changeDate.getTime() + 15 * 24 * 60 * 60 * 1000)\n          },\n          reason: `Cambio de placas a ${to.plateNumber} (${to.state}) sin alta documentada`,\n          severity: 'high',\n          relatedDocuments: relatedDocs.map((doc: any) => doc.id),\n          suggestedAction: `Solicitar copia de alta de placas ${to.plateNumber} en ${MEXICAN_STATES[to.state as keyof typeof MEXICAN_STATES].issuingAuthority}`,\n          estimatedCost: 300,\n          issuingAuthority: MEXICAN_STATES[to.state as keyof typeof MEXICAN_STATES].issuingAuthority,\n          requiredDocuments: ['factura_endosada', 'contrato_compraventa']\n        });\n      }\n    }\n\n    return gaps;\n  }\n\n  /**\n   * REGLA 2: Detección de gaps por cambio de propietario\n   * Por cada cambio de nombre detectado:\n   * - Debe existir factura endosada O refactura\n   * - Nueva tarjeta de circulación dentro de 15-30 días\n   * - Si cambió de estado, aplicar regla de placas\n   * - Contrato de compraventa debe estar presente\n   */\n  detectOwnershipGaps(documents: VehicleDocument[]): DocumentGap[] {\n    const gaps: DocumentGap[] = [];\n    const ownershipChanges = this.identifyOwnershipChanges(documents);\n\n    for (const change of ownershipChanges) {\n      const { from, to, changeDate, documents: relatedDocs } = change;\n\n      // Verificar factura endosada o refactura\n      const transferDocExists = documents.some(doc => \n        (doc.type === 'factura_endosada' || doc.type === 'refactura') &&\n        doc.ownerName === to.ownerName &&\n        Math.abs(doc.issueDate.getTime() - changeDate.getTime()) <= 30 * 24 * 60 * 60 * 1000\n      );\n\n      if (!transferDocExists) {\n        gaps.push({\n          id: `transfer_doc_${to.ownerName}_${changeDate.getTime()}`,\n          type: 'factura_endosada',\n          expectedDateRange: {\n            from: new Date(changeDate.getTime() - 15 * 24 * 60 * 60 * 1000),\n            to: new Date(changeDate.getTime() + 15 * 24 * 60 * 60 * 1000)\n          },\n          reason: `Cambio de propietario de \"${from.ownerName}\" a \"${to.ownerName}\" sin documento de transferencia`,\n          severity: 'critical',\n          relatedDocuments: relatedDocs.map((doc: any) => doc.id),\n          suggestedAction: 'Obtener factura endosada o refactura que documente la transferencia',\n          estimatedCost: 800,\n          requiredDocuments: ['factura_origen', 'contrato_compraventa']\n        });\n      }\n\n      // Verificar nueva tarjeta de circulación\n      const newCirculationCard = documents.find(doc => \n        doc.type === 'tarjeta_circulacion' &&\n        doc.ownerName === to.ownerName &&\n        Math.abs(doc.issueDate.getTime() - changeDate.getTime()) <= 30 * 24 * 60 * 60 * 1000\n      );\n\n      if (!newCirculationCard) {\n        gaps.push({\n          id: `new_circulation_card_${to.ownerName}_${changeDate.getTime()}`,\n          type: 'tarjeta_circulacion',\n          expectedDateRange: {\n            from: new Date(changeDate.getTime() - 15 * 24 * 60 * 60 * 1000),\n            to: new Date(changeDate.getTime() + 15 * 24 * 60 * 60 * 1000)\n          },\n          reason: `Nuevo propietario \"${to.ownerName}\" sin tarjeta de circulación actualizada`,\n          severity: 'high',\n          relatedDocuments: relatedDocs.map((doc: any) => doc.id),\n          suggestedAction: 'Actualizar tarjeta de circulación con datos del nuevo propietario',\n          estimatedCost: 400,\n          requiredDocuments: ['factura_endosada', 'alta_placas']\n        });\n      }\n\n      // Verificar contrato de compraventa\n      const contractExists = documents.some(doc => \n        doc.type === 'contrato_compraventa' &&\n        doc.ownerName === to.ownerName &&\n        Math.abs(doc.issueDate.getTime() - changeDate.getTime()) <= 30 * 24 * 60 * 60 * 1000\n      );\n\n      if (!contractExists) {\n        gaps.push({\n          id: `contract_${to.ownerName}_${changeDate.getTime()}`,\n          type: 'contrato_compraventa',\n          expectedDateRange: {\n            from: new Date(changeDate.getTime() - 15 * 24 * 60 * 60 * 1000),\n            to: new Date(changeDate.getTime() + 15 * 24 * 60 * 60 * 1000)\n          },\n          reason: `Transferencia de propiedad sin contrato de compraventa documentado`,\n          severity: 'medium',\n          relatedDocuments: relatedDocs.map((doc: any) => doc.id),\n          suggestedAction: 'Obtener contrato de compraventa firmado por ambas partes',\n          estimatedCost: 200,\n          requiredDocuments: ['identificaciones', 'comprobantes_domicilio']\n        });\n      }\n    }\n\n    return gaps;\n  }\n\n  /**\n   * REGLA 3: Detección de gaps en pagos anuales obligatorios\n   * Para cada año desde la compra:\n   * - Debe existir tenencia O refrendo pagado\n   * - No puede haber años sin pago\n   * - Excepción: estados que condonaron el impuesto\n   * - Nombre en recibo debe coincidir con propietario del periodo\n   */\n  detectAnnualPaymentGaps(documents: VehicleDocument[]): DocumentGap[] {\n    const gaps: DocumentGap[] = [];\n    const paymentYears = this.getPaymentYears(documents);\n\n    for (const year of paymentYears) {\n      const yearStart = new Date(year, 0, 1);\n      const yearEnd = new Date(year, 11, 31);\n      \n      // Obtener propietario del año\n      const yearOwner = this.getOwnerForYear(documents, year);\n      if (!yearOwner) continue;\n\n      // Verificar si el estado tiene tenencia o refrendo\n      const state = yearOwner.state;\n      const stateConfig = MEXICAN_STATES[state];\n      \n      if (!stateConfig.hasTenencia && !stateConfig.hasRefrendo) {\n        continue; // Estado que no requiere pago anual\n      }\n\n      // Buscar pago del año\n      const paymentExists = documents.some(doc => {\n        const docYear = doc.issueDate.getFullYear();\n        const isPaymentDoc = stateConfig.hasTenencia ? doc.type === 'tenencia' : doc.type === 'refrendo';\n        const isCorrectYear = docYear === year;\n        const isCorrectOwner = doc.ownerName === yearOwner.ownerName;\n        const isCorrectState = doc.state === state;\n        \n        return isPaymentDoc && isCorrectYear && isCorrectOwner && isCorrectState;\n      });\n\n      if (!paymentExists) {\n        const paymentType = stateConfig.hasTenencia ? 'tenencia' : 'refrendo';\n        const paymentName = stateConfig.hasTenencia ? 'Tenencia' : 'Refrendo';\n        \n        gaps.push({\n          id: `${paymentType}_${year}_${yearOwner.ownerName}`,\n          type: paymentType,\n          expectedDateRange: {\n            from: yearStart,\n            to: yearEnd\n          },\n          reason: `Falta pago de ${paymentName} ${year} para propietario \"${yearOwner.ownerName}\" en ${state}`,\n          severity: 'high',\n          relatedDocuments: [],\n          suggestedAction: `Pagar ${paymentName} ${year} en ${stateConfig.issuingAuthority}`,\n          estimatedCost: this.estimatePaymentCost(year, state),\n          issuingAuthority: stateConfig.issuingAuthority,\n          requiredDocuments: ['tarjeta_circulacion', 'verificacion']\n        });\n      }\n    }\n\n    return gaps;\n  }\n\n  /**\n   * REGLA 4: Detección de gaps en verificaciones vehiculares\n   * Según el estado (CDMX, EdoMex, etc):\n   * - Semestral: 2 verificaciones por año\n   * - Anual: 1 verificación por año\n   * - Placas deben coincidir con las del periodo\n   * - No gaps mayores a un periodo\n   */\n  detectVerificationGaps(documents: VehicleDocument[]): DocumentGap[] {\n    const gaps: DocumentGap[] = [];\n    const verificationYears = this.getVerificationYears(documents);\n\n    for (const year of verificationYears) {\n      const yearStart = new Date(year, 0, 1);\n      const yearEnd = new Date(year, 11, 31);\n      \n      // Obtener propietario y placas del año\n      const yearOwner = this.getOwnerForYear(documents, year);\n      if (!yearOwner) continue;\n\n      const state = yearOwner.state;\n      const stateConfig = MEXICAN_STATES[state];\n      const requiredVerifications = stateConfig.verificationFrequency === 'semiannual' ? 2 : 1;\n\n      // Buscar verificaciones del año\n      const verifications = documents.filter(doc => \n        doc.type === 'verificacion' &&\n        doc.issueDate.getFullYear() === year &&\n        doc.ownerName === yearOwner.ownerName &&\n        doc.state === state\n      );\n\n      if (verifications.length < requiredVerifications) {\n        const missing = requiredVerifications - verifications.length;\n        const frequency = stateConfig.verificationFrequency === 'semiannual' ? 'semestral' : 'anual';\n        \n        gaps.push({\n          id: `verificacion_${year}_${yearOwner.ownerName}_${missing}`,\n          type: 'verificacion',\n          expectedDateRange: {\n            from: yearStart,\n            to: yearEnd\n          },\n          reason: `Faltan ${missing} verificación(es) ${frequency} ${year} para placas ${yearOwner.plateNumber || 'N/A'}`,\n          severity: 'medium',\n          relatedDocuments: verifications.map(doc => doc.id),\n          suggestedAction: `Realizar ${missing} verificación(es) vehicular(es) en ${stateConfig.issuingAuthority}`,\n          estimatedCost: missing * 200,\n          issuingAuthority: stateConfig.issuingAuthority,\n          requiredDocuments: ['tarjeta_circulacion', 'tenencia', 'refrendo']\n        });\n      }\n    }\n\n    return gaps;\n  }\n\n  /**\n   * REGLA 5: Validación de cadena de propiedad completa\n   * Desde factura origen hasta propietario actual:\n   * - Cada transferencia debe estar documentada\n   * - Secuencia: Factura origen → Endoso/Refactura → ... → Dueño actual\n   * - No puede haber saltos en la cadena\n   * - Fechas deben ser secuenciales\n   */\n  validateOwnershipChain(documents: VehicleDocument[]): ValidationResult {\n    const issues: string[] = [];\n    const ownershipChain: any[] = [];\n    const missingTransfers: any[] = [];\n\n    // Ordenar documentos por fecha\n    const sortedDocs = documents\n      .filter(doc => ['factura_origen', 'factura_endosada', 'refactura'].includes(doc.type))\n      .sort((a, b) => a.issueDate.getTime() - b.issueDate.getTime());\n\n    if (sortedDocs.length === 0) {\n      issues.push('No se encontraron documentos de propiedad');\n      return { isValid: false, issues, ownershipChain, missingTransfers };\n    }\n\n    // Verificar factura origen\n    const facturaOrigen = sortedDocs.find(doc => doc.type === 'factura_origen');\n    if (!facturaOrigen) {\n      issues.push('Falta factura de origen del vehículo');\n    } else {\n      ownershipChain.push({\n        from: 'Concesionario',\n        to: facturaOrigen.ownerName,\n        transferDate: facturaOrigen.issueDate,\n        documentId: facturaOrigen.id\n      });\n    }\n\n    // Verificar transferencias secuenciales\n    let currentOwner = facturaOrigen?.ownerName;\n    for (let i = 1; i < sortedDocs.length; i++) {\n      const doc = sortedDocs[i];\n      const prevDoc = sortedDocs[i - 1];\n\n      if (doc.ownerName !== currentOwner) {\n        // Hay un cambio de propietario\n        ownershipChain.push({\n          from: currentOwner,\n          to: doc.ownerName,\n          transferDate: doc.issueDate,\n          documentId: doc.id\n        });\n\n        // Verificar que la fecha sea posterior a la anterior\n        if (doc.issueDate <= prevDoc.issueDate) {\n          issues.push(`Fecha de transferencia inválida: ${doc.issueDate.toISOString()} debe ser posterior a ${prevDoc.issueDate.toISOString()}`);\n        }\n\n        currentOwner = doc.ownerName;\n      }\n    }\n\n    // Verificar que no haya saltos en la cadena\n    const uniqueOwners = Array.from(new Set(sortedDocs.map(doc => doc.ownerName)));\n    if (uniqueOwners.length > 1) {\n      for (let i = 1; i < uniqueOwners.length; i++) {\n        const prevOwner = uniqueOwners[i - 1];\n        const currentOwner = uniqueOwners[i];\n        \n        const hasTransfer = ownershipChain.some(transfer => \n          transfer.from === prevOwner && transfer.to === currentOwner\n        );\n\n        if (!hasTransfer) {\n          missingTransfers.push({\n            from: prevOwner,\n            to: currentOwner,\n            expectedDate: new Date(),\n            reason: 'Transferencia no documentada en la cadena de propiedad'\n          });\n          issues.push(`Falta documentación de transferencia de ${prevOwner} a ${currentOwner}`);\n        }\n      }\n    }\n\n    return {\n      isValid: issues.length === 0 && missingTransfers.length === 0,\n      issues,\n      ownershipChain,\n      missingTransfers\n    };\n  }\n\n  /**\n   * REGLA 6: Verificación de consistencia temporal\n   * Verificar que:\n   * - No hay documentos con fechas imposibles\n   * - Documentos del mismo periodo tienen mismo propietario\n   * - Multas corresponden al propietario del momento\n   * - Tarjeta de circulación vigente durante todo el periodo\n   */\n  checkTemporalConsistency(documents: VehicleDocument[]): TemporalIssue[] {\n    const issues: TemporalIssue[] = [];\n\n    // Verificar fechas imposibles\n    const now = new Date();\n    const minDate = new Date(1900, 0, 1);\n    \n    for (const doc of documents) {\n      if (doc.issueDate < minDate || doc.issueDate > now) {\n        issues.push({\n          id: `impossible_date_${doc.id}`,\n          type: 'impossible_date',\n          description: `Documento ${doc.type} tiene fecha imposible: ${doc.issueDate.toISOString()}`,\n          affectedDocuments: [doc.id],\n          severity: 'high',\n          suggestedFix: 'Verificar fecha de emisión del documento'\n        });\n      }\n    }\n\n    // Verificar consistencia de propietarios por periodo\n    const ownerConsistency = this.checkOwnerConsistency(documents);\n    issues.push(...ownerConsistency);\n\n    // Verificar tarjeta de circulación vigente\n    const circulationIssues = this.checkCirculationCardValidity(documents);\n    issues.push(...circulationIssues);\n\n    return issues;\n  }\n\n  /**\n   * Análisis completo de completitud de documentos\n   */\n  analyzeDocumentCompleteness(documents: VehicleDocument[]): AnalysisResult {\n    // Aplicar todas las reglas\n    const plateGaps = this.detectPlateChangeGaps(documents);\n    const ownershipGaps = this.detectOwnershipGaps(documents);\n    const paymentGaps = this.detectAnnualPaymentGaps(documents);\n    const verificationGaps = this.detectVerificationGaps(documents);\n    const temporalIssues = this.checkTemporalConsistency(documents);\n    const ownershipValidation = this.validateOwnershipChain(documents);\n\n    // Combinar todos los gaps\n    const allGaps = [...plateGaps, ...ownershipGaps, ...paymentGaps, ...verificationGaps];\n\n    // Calcular score de completitud\n    const totalExpected = this.calculateExpectedDocuments(documents);\n    const presentDocuments = documents.length;\n    const completenessPercentage = totalExpected > 0 ? (presentDocuments / totalExpected) * 100 : 0;\n    \n    // Calcular score (0-100)\n    let score = 100;\n    score -= plateGaps.filter(gap => gap.severity === 'critical').length * 20;\n    score -= plateGaps.filter(gap => gap.severity === 'high').length * 15;\n    score -= ownershipGaps.filter(gap => gap.severity === 'critical').length * 25;\n    score -= ownershipGaps.filter(gap => gap.severity === 'high').length * 20;\n    score -= paymentGaps.filter(gap => gap.severity === 'high').length * 10;\n    score -= verificationGaps.filter(gap => gap.severity === 'medium').length * 5;\n    score -= temporalIssues.filter(issue => issue.severity === 'critical').length * 15;\n    \n    score = Math.max(0, Math.min(100, score));\n\n    // Determinar nivel de riesgo\n    let riskLevel: 'low' | 'medium' | 'high' | 'critical' = 'low';\n    if (score < 30) riskLevel = 'critical';\n    else if (score < 50) riskLevel = 'high';\n    else if (score < 70) riskLevel = 'medium';\n\n    // Generar recomendaciones\n    const recommendations = this.generateRecommendations(allGaps, temporalIssues, ownershipValidation);\n\n    // Agrupar gaps por severidad\n    const priorityActions = {\n      critical: allGaps.filter(gap => gap.severity === 'critical'),\n      high: allGaps.filter(gap => gap.severity === 'high'),\n      medium: allGaps.filter(gap => gap.severity === 'medium'),\n      low: allGaps.filter(gap => gap.severity === 'low')\n    };\n\n    // Calcular desglose por categoría\n    const categoryBreakdown = this.calculateCategoryBreakdown(documents, allGaps);\n\n    return {\n      score,\n      gaps: allGaps,\n      completenessPercentage,\n      criticalIssues: allGaps.filter(gap => gap.severity === 'critical').map(gap => gap.reason),\n      recommendations,\n      riskLevel,\n      temporalIssues,\n      ownershipValidation,\n      categoryBreakdown,\n      priorityActions\n    };\n  }\n\n  // Métodos auxiliares privados\n\n  private identifyPlateChanges(documents: VehicleDocument[]): any[] {\n    const changes: any[] = [];\n    const circulationCards = documents\n      .filter(doc => doc.type === 'tarjeta_circulacion' && doc.plateNumber)\n      .sort((a, b) => a.issueDate.getTime() - b.issueDate.getTime());\n\n    for (let i = 1; i < circulationCards.length; i++) {\n      const prev = circulationCards[i - 1];\n      const curr = circulationCards[i];\n\n      if (prev.plateNumber !== curr.plateNumber || prev.state !== curr.state) {\n        changes.push({\n          from: { plateNumber: prev.plateNumber, state: prev.state },\n          to: { plateNumber: curr.plateNumber, state: curr.state },\n          changeDate: curr.issueDate,\n          documents: [prev, curr]\n        });\n      }\n    }\n\n    return changes;\n  }\n\n  private identifyOwnershipChanges(documents: VehicleDocument[]): any[] {\n    const changes: any[] = [];\n    const allDocs = documents\n      .filter(doc => doc.ownerName)\n      .sort((a, b) => a.issueDate.getTime() - b.issueDate.getTime());\n\n    for (let i = 1; i < allDocs.length; i++) {\n      const prev = allDocs[i - 1];\n      const curr = allDocs[i];\n\n      if (prev.ownerName !== curr.ownerName) {\n        changes.push({\n          from: { ownerName: prev.ownerName },\n          to: { ownerName: curr.ownerName },\n          changeDate: curr.issueDate,\n          documents: [prev, curr]\n        });\n      }\n    }\n\n    return changes;\n  }\n\n  private getPaymentYears(documents: VehicleDocument[]): number[] {\n    const years = new Set<number>();\n    const startYear = Math.min(...documents.map(doc => doc.issueDate.getFullYear()));\n    const currentYear = new Date().getFullYear();\n\n    for (let year = startYear; year <= currentYear; year++) {\n      years.add(year);\n    }\n\n    return Array.from(years);\n  }\n\n  private getVerificationYears(documents: VehicleDocument[]): number[] {\n    return this.getPaymentYears(documents);\n  }\n\n  private getOwnerForYear(documents: VehicleDocument[], year: number): { ownerName: string; state: MexicanState; plateNumber?: string } | null {\n    const yearDocs = documents.filter(doc => doc.issueDate.getFullYear() === year);\n    if (yearDocs.length === 0) return null;\n\n    // Buscar el propietario más reciente del año\n    const latestDoc = yearDocs.sort((a, b) => b.issueDate.getTime() - a.issueDate.getTime())[0];\n    \n    return {\n      ownerName: latestDoc.ownerName,\n      state: latestDoc.state,\n      plateNumber: latestDoc.plateNumber\n    };\n  }\n\n  private estimatePaymentCost(year: number, state: MexicanState): number {\n    // Estimación básica de costos por año y estado\n    const baseCost = 1000;\n    const yearMultiplier = Math.max(1, (new Date().getFullYear() - year) * 0.1);\n    return Math.round(baseCost * yearMultiplier);\n  }\n\n  private checkOwnerConsistency(documents: VehicleDocument[]): TemporalIssue[] {\n    const issues: TemporalIssue[] = [];\n    const ownerByPeriod = new Map<string, string>();\n\n    for (const doc of documents) {\n      const period = `${doc.issueDate.getFullYear()}-${doc.issueDate.getMonth()}`;\n      const existingOwner = ownerByPeriod.get(period);\n      \n      if (existingOwner && existingOwner !== doc.ownerName) {\n        issues.push({\n          id: `owner_mismatch_${period}`,\n          type: 'owner_mismatch',\n          description: `Inconsistencia de propietario en ${period}: ${existingOwner} vs ${doc.ownerName}`,\n          affectedDocuments: documents\n            .filter(d => `${d.issueDate.getFullYear()}-${d.issueDate.getMonth()}` === period)\n            .map(d => d.id),\n          severity: 'medium',\n          suggestedFix: 'Verificar propietario correcto para el periodo'\n        });\n      } else {\n        ownerByPeriod.set(period, doc.ownerName);\n      }\n    }\n\n    return issues;\n  }\n\n  private checkCirculationCardValidity(documents: VehicleDocument[]): TemporalIssue[] {\n    const issues: TemporalIssue[] = [];\n    const circulationCards = documents\n      .filter(doc => doc.type === 'tarjeta_circulacion')\n      .sort((a, b) => a.issueDate.getTime() - b.issueDate.getTime());\n\n    for (let i = 1; i < circulationCards.length; i++) {\n      const prev = circulationCards[i - 1];\n      const curr = circulationCards[i];\n      \n      const gapDays = (curr.issueDate.getTime() - prev.issueDate.getTime()) / (1000 * 60 * 60 * 24);\n      \n      if (gapDays > 30) {\n        issues.push({\n          id: `circulation_gap_${prev.id}_${curr.id}`,\n          type: 'impossible_date',\n          description: `Gap de ${Math.round(gapDays)} días entre tarjetas de circulación`,\n          affectedDocuments: [prev.id, curr.id],\n          severity: 'medium',\n          suggestedFix: 'Verificar si falta documentación intermedia'\n        });\n      }\n    }\n\n    return issues;\n  }\n\n  private calculateExpectedDocuments(documents: VehicleDocument[]): number {\n    // Cálculo básico de documentos esperados\n    const years = this.getPaymentYears(documents);\n    let expected = 1; // Factura origen\n\n    // Agregar documentos por año\n    years.forEach(year => {\n      expected += 1; // Tenencia o refrendo\n      expected += 1; // Verificación\n    });\n\n    // Agregar documentos de transferencia\n    const ownershipChanges = this.identifyOwnershipChanges(documents);\n    expected += ownershipChanges.length * 2; // Endoso + nueva tarjeta\n\n    return expected;\n  }\n\n  private generateRecommendations(gaps: DocumentGap[], temporalIssues: TemporalIssue[], ownershipValidation: ValidationResult): string[] {\n    const recommendations: string[] = [];\n\n    if (gaps.filter(gap => gap.severity === 'critical').length > 0) {\n      recommendations.push('1. URGENTE: Resolver gaps críticos de documentación');\n    }\n\n    if (ownershipValidation.missingTransfers.length > 0) {\n      recommendations.push('2. Completar cadena de propiedad faltante');\n    }\n\n    if (gaps.filter(gap => gap.type === 'tenencia' || gap.type === 'refrendo').length > 0) {\n      recommendations.push('3. Regularizar pagos anuales pendientes');\n    }\n\n    if (gaps.filter(gap => gap.type === 'verificacion').length > 0) {\n      recommendations.push('4. Realizar verificaciones vehiculares faltantes');\n    }\n\n    if (temporalIssues.length > 0) {\n      recommendations.push('5. Corregir inconsistencias temporales');\n    }\n\n    return recommendations;\n  }\n\n  private calculateCategoryBreakdown(documents: VehicleDocument[], gaps: DocumentGap[]): any {\n    const ownership = {\n      present: documents.filter(doc => ['factura_origen', 'factura_endosada', 'refactura'].includes(doc.type)).length,\n      expected: 1 + gaps.filter(gap => ['factura_endosada', 'refactura'].includes(gap.type)).length,\n      percentage: 0\n    };\n\n    const fiscal = {\n      present: documents.filter(doc => ['tenencia', 'refrendo'].includes(doc.type)).length,\n      expected: documents.filter(doc => ['tenencia', 'refrendo'].includes(doc.type)).length + gaps.filter(gap => ['tenencia', 'refrendo'].includes(gap.type)).length,\n      percentage: 0\n    };\n\n    const registration = {\n      present: documents.filter(doc => ['alta_placas', 'baja_placas', 'tarjeta_circulacion'].includes(doc.type)).length,\n      expected: documents.filter(doc => ['alta_placas', 'baja_placas', 'tarjeta_circulacion'].includes(doc.type)).length + gaps.filter(gap => ['alta_placas', 'baja_placas', 'tarjeta_circulacion'].includes(gap.type)).length,\n      percentage: 0\n    };\n\n    const verification = {\n      present: documents.filter(doc => doc.type === 'verificacion').length,\n      expected: documents.filter(doc => doc.type === 'verificacion').length + gaps.filter(gap => gap.type === 'verificacion').length,\n      percentage: 0\n    };\n\n    // Calcular porcentajes\n    ownership.percentage = ownership.expected > 0 ? (ownership.present / ownership.expected) * 100 : 100;\n    fiscal.percentage = fiscal.expected > 0 ? (fiscal.present / fiscal.expected) * 100 : 100;\n    registration.percentage = registration.expected > 0 ? (registration.present / registration.expected) * 100 : 100;\n    verification.percentage = verification.expected > 0 ? (verification.present / verification.expected) * 100 : 100;\n\n    return { ownership, fiscal, registration, verification };\n  }\n}\n\nexport const documentGapAnalyzer = new DocumentGapAnalyzer();\nexport default documentGapAnalyzer;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}