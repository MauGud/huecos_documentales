CONTEXTO COMPLETO DEL PROYECTO - ANALIZADOR DE SECUENCIA DE PROPIEDAD VEHICULAR

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ALCANCE Y OBJETIVO DEL PROYECTO
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Este es un sistema Node.js/Express que analiza la cadena de propiedad vehicular mediante documentos fiscales (facturas, refacturas, endosos) obtenidos de la API Nexcar. El objetivo principal es detectar huecos, retornos vÃ¡lidos y anomalÃ­as en la secuencia de transferencias de propiedad desde el origen (vehÃ­culo nuevo) hasta el propietario actual.

El sistema procesa tres tipos de documentos fiscales:
- invoice: Factura original de vehÃ­culo nuevo (usado_nuevo: "NUEVO")
- reinvoice: Refactura de transferencias posteriores (usado_nuevo: "USADO" por defecto)
- endorsement: Endoso legal de transferencia de derechos

La lÃ³gica crÃ­tica estÃ¡ en src/api/sequenceAnalyzer.js, especÃ­ficamente en el mÃ©todo analyzeOwnershipSequence() que construye la cadena de propiedad validando que el RFC receptor de un documento sea el RFC emisor del siguiente documento en la secuencia.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ARQUITECTURA Y ESTRUCTURA
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Estructura de archivos:
- src/server.js: Servidor Express en puerto 3000, sirve archivos estÃ¡ticos de /public y rutas /api
- src/api/routes.js: Endpoints REST (POST /api/auth, POST /api/fetch-expediente, POST /api/analyze-sequence)
- src/api/nexcarClient.js: Cliente HTTP con Axios para API Nexcar (autenticaciÃ³n JWT, obtenciÃ³n de expedientes)
- src/api/sequenceAnalyzer.js: â­ MOTOR PRINCIPAL - LÃ³gica completa de anÃ¡lisis de secuencia
- public/index.html: Interfaz web con formularios de autenticaciÃ³n, bÃºsqueda y visualizaciÃ³n
- public/app_new.js: LÃ³gica frontend con Fetch API para comunicaciÃ³n con backend
- public/styles.css: Estilos CSS modernos con diseÃ±o morado/blanco

Stack: Node.js + Express (backend), JavaScript vanilla (frontend), Axios (HTTP client), CORS habilitado.

API Externa: Nexcar API en https://nexcar-api-770231222dff.herokuapp.com
- POST /auth/token: AutenticaciÃ³n con email/password, retorna JWT token
- GET /expediente/{vehicleId}: Obtiene expediente completo con todos los archivos y datos OCR

Credenciales por defecto hardcodeadas en routes.js: facturacion@nexcar.mx / M4u2025!!

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FLUJO DE TRABAJO COMPLETO
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

PASO 1 - AutenticaciÃ³n:
Usuario ingresa email/password â†’ Frontend llama POST /api/auth â†’ NexcarClient.authenticate() â†’ API Nexcar retorna JWT â†’ Token almacenado en memoria (nexcarClient.accessToken y nexcarClient.tokenExpiry). El token es vÃ¡lido si faltan mÃ¡s de 5 minutos para expirar (margen de seguridad).

PASO 2 - ObtenciÃ³n de Expediente:
Usuario ingresa URL de Nexcar (ej: https://app.nexcar.mx/workspace-analysis/{vehicle_id}/#!) o Vehicle ID directo (UUID) â†’ Frontend llama POST /api/fetch-expediente â†’ Sistema extrae Vehicle ID de URL usando regex /workspace-analysis\/([0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})/ â†’ Si token invÃ¡lido, autentica automÃ¡ticamente â†’ NexcarClient.getExpediente(vehicleId) â†’ API Nexcar retorna expediente completo â†’ Expediente almacenado en memoria (currentExpediente en routes.js) â†’ Respuesta estructurada con invoices, reinvoices, endorsements separados.

PASO 3 - AnÃ¡lisis de Secuencia (LÃ“GICA PRINCIPAL):
Usuario hace clic en "Analizar Secuencia" â†’ Frontend llama POST /api/analyze-sequence â†’ SequenceAnalyzer.analyzeOwnershipSequence(expedienteData) ejecuta el algoritmo completo â†’ Retorna cadena de propiedad, huecos detectados, retornos vÃ¡lidos, documentos huÃ©rfanos.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ESTRUCTURA DE DATOS DE ENTRADA (EXPEDIENTE NEXCAR)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

El expediente de Nexcar tiene esta estructura JSON:

{
  active_vehicle: true/false,
  created_at: "2025-09-26T...",
  files: [
    {
      file_id: "uuid-string",
      document_type: "invoice" | "reinvoice" | "endorsement" | "other",
      created_at: "2025-09-26T...",
      url: "https://...",
      ocr: {
        // Para INVOICE (factura):
        fecha_factura: "25/06/2020" o fecha_hora_emision,
        numero_factura: "12345" o folio_fiscal,
        rfc_emisor: "COA030402N59",
        nombre_emisor: "Car One Americana",
        rfc_receptor: "LFC1106205B4",
        nombre_receptor: "Lumo Financiera Del Centro",
        total: "450000.00",
        usado_nuevo: "NUEVO" | "USADO",
        vin: "3GCPY9EH8LG352317" o niv_vin_numero_serie,
        marca_vehiculo: "CHEVROLET",
        modelo_vehiculo: "SILVERADO DOBLE",
        ano_vehiculo: "2020" o vehiculo_modelo_ano,
        
        // Para REINVOICE (refactura):
        fecha_refactura: "15/08/2021" o fecha_factura o fecha_hora_emision,
        numero_refactura: "67890" o numero_factura o folio_fiscal,
        // Mismos campos rfc_emisor, rfc_receptor, etc.
        // usado_nuevo puede ser "USADO" o null (por defecto se asume "USADO"),
        
        // Para ENDORSEMENT (endoso):
        fecha_endoso: "10/09/2021" o fecha_hora_endoso,
        numero_endoso: "END-001" o folio_endoso,
        rfc_endosante: "RFC-A",  // Equivale a emisor
        nombre_endosante: "Nombre A",
        rfc_endosatario: "RFC-B", // Equivale a receptor
        nombre_endosatario: "Nombre B",
        // NO tiene total ni usado_nuevo
      }
    }
  ]
}

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ALGORITMO DE ANÃLISIS DE SECUENCIA (sequenceAnalyzer.js) - LÃ“GICA DETALLADA
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

El mÃ©todo analyzeOwnershipSequence(expedienteData) ejecuta estos pasos:

PASO 1 - FILTRADO DE DOCUMENTOS RELEVANTES:
Filtra files[] para obtener solo documentos con document_type === 'invoice' || 'reinvoice' || 'endorsement' Y que tengan ocr vÃ¡lido (objeto no null). Ignora documentos sin OCR o de otros tipos.

PASO 2 - EXTRACCIÃ“N Y VALIDACIÃ“N DE VIN:
Extrae VIN de referencia buscando en todos los archivos del expediente: ocr.vin o ocr.niv_vin_numero_serie. Luego valida que todos los documentos tengan el mismo VIN. Si hay VINs diferentes, retorna error y detiene el anÃ¡lisis.

PASO 3 - NORMALIZACIÃ“N DE DOCUMENTOS:
Cada tipo de documento tiene campos OCR diferentes. Se normalizan a una estructura comÃºn usando normalizeDocument(doc):

Para INVOICE:
{
  fileId: doc.file_id,
  documentType: 'invoice',
  fecha: ocr.fecha_factura || ocr.fecha_hora_emision,
  numeroDocumento: ocr.numero_factura || ocr.folio_fiscal,
  emisorRFC: ocr.rfc_emisor,
  emisorNombre: ocr.nombre_emisor,
  receptorRFC: ocr.rfc_receptor,
  receptorNombre: ocr.nombre_receptor,
  total: ocr.total,
  usadoNuevo: ocr.usado_nuevo, // "NUEVO" o "USADO"
  vin: ocr.vin || ocr.niv_vin_numero_serie,
  vehiculo: { marca: ocr.marca_vehiculo, modelo: ocr.modelo_vehiculo, ano: ocr.ano_vehiculo || ocr.vehiculo_modelo_ano }
}

Para REINVOICE:
Similar pero con campos: fecha_refactura || fecha_factura || fecha_hora_emision, numero_refactura || numero_factura || folio_fiscal. usadoNuevo por defecto es 'USADO' si no estÃ¡ presente.

Para ENDORSEMENT:
{
  fileId: doc.file_id,
  documentType: 'endorsement',
  fecha: ocr.fecha_endoso || ocr.fecha_hora_endoso,
  numeroDocumento: ocr.numero_endoso || ocr.folio_endoso,
  emisorRFC: ocr.rfc_endosante,  // Mapeo especial
  emisorNombre: ocr.nombre_endosante,
  receptorRFC: ocr.rfc_endosatario, // Mapeo especial
  receptorNombre: ocr.nombre_endosatario,
  total: null, // Endosos no tienen monto
  usadoNuevo: null, // Endosos no tienen este campo
  vin: ocr.vin || ocr.niv_vin_numero_serie,
  vehiculo: { marca, modelo, ano }
}

PASO 4 - IDENTIFICACIÃ“N DEL DOCUMENTO DE ORIGEN:
Busca el primer documento normalizado donde usadoNuevo === 'NUEVO' (case insensitive). Este es el documento de origen que representa la primera venta: Concesionaria â†’ Primer Propietario. Si no se encuentra, retorna error. Este documento serÃ¡ la posiciÃ³n 1 en la cadena.

PASO 5 - ORDENAMIENTO POR FECHA:
Ordena todos los documentos normalizados por fecha ascendente (mÃ¡s antiguo primero). parseDate() soporta formatos DD/MM/YYYY, YYYY-MM-DD, y cualquier formato parseable por new Date(). Documentos sin fecha van al final.

PASO 6 - CONSTRUCCIÃ“N DE CADENA DE PROPIEDAD (LÃ“GICA CRÃTICA):
Este es el corazÃ³n del algoritmo en buildOwnershipChainAdvanced(documents, originDocument):

InicializaciÃ³n:
- chain = [] (array de elementos de la cadena)
- rfcHistory = [] (historial de RFCs que han aparecido)
- processedDocs = new Set() (documentos ya procesados)
- currentReceptorRFC = originDocument.receptorRFC (RFC del propietario actual)
- position = 2 (el origen es posiciÃ³n 1)

Agregar documento de origen:
chain.push({
  position: 1,
  state: 'OK',
  stateLabel: 'âœ“ Origen',
  type: originDocument.documentType,
  ...extractChainData(originDocument) // Incluye fileId, fecha, rfcEmisor, rfcReceptor, etc.
})
rfcHistory.push(originDocument.emisorRFC, originDocument.receptorRFC)
processedDocs.add(originDocument.fileId)

Iterar sobre documentos ordenados:
Para cada documento doc en documents (ordenados por fecha):
  Si ya fue procesado, continuar.
  
  Calcular variables de estado:
  - isContinuation = (doc.emisorRFC === currentReceptorRFC)
    // El emisor es quien posee actualmente â†’ continuaciÃ³n normal
  - rfcAppearedBefore = rfcHistory.includes(doc.emisorRFC)
    // El RFC emisor ya apareciÃ³ antes en la cadena
  - isPotentialReturn = rfcAppearedBefore && !isContinuation
    // RFC apareciÃ³ antes PERO no es el poseedor actual â†’ posible retorno
  
  CASO 1 - CONTINUACIÃ“N NORMAL (PRIORIDAD MÃXIMA):
  Si isContinuation === true:
    Determinar estado segÃºn tipo:
    - Si documentType === 'endorsement': state = 'ENDOSO', stateLabel = 'ğŸ“‹ Endoso'
    - Si documentType === 'reinvoice': state = 'REFACTURA', stateLabel = 'ğŸ”„ Refactura'
    - Si no: state = 'OK', stateLabel = 'âœ“ OK'
    
    Agregar a cadena:
    chain.push({
      position: position++,
      state: state,
      stateLabel: stateLabel,
      type: doc.documentType,
      ...extractChainData(doc)
    })
    
    Actualizar estado:
    rfcHistory.push(doc.receptorRFC)
    processedDocs.add(doc.fileId)
    currentReceptorRFC = doc.receptorRFC // Nuevo propietario actual
  
  CASO 2 - RETORNO VÃLIDO (solo si NO es continuaciÃ³n):
  Si isPotentialReturn === true:
    Validar retorno con validateReturn(doc, chain, rfcHistory, currentReceptorRFC):
      - El RFC emisor debe estar en rfcHistory (ya apareciÃ³ antes)
      - CRÃTICO: Si doc.emisorRFC === currentReceptorRFC, NO es retorno (es continuaciÃ³n normal)
      - El VIN debe coincidir con VINs de la cadena
      - Retorna true si es retorno vÃ¡lido
    
    Si es retorno vÃ¡lido:
      chain.push({
        position: position++,
        state: 'RETORNO',
        stateLabel: 'ğŸ”„ Retorno',
        type: doc.documentType,
        ...extractChainData(doc)
      })
      rfcHistory.push(doc.receptorRFC)
      processedDocs.add(doc.fileId)
      currentReceptorRFC = doc.receptorRFC

CASO 3 - DOCUMENTOS NO PROCESADOS = RUPTURAS:
DespuÃ©s de iterar, para cada documento que NO estÃ¡ en processedDocs:
  chain.push({
    position: null, // Sin posiciÃ³n porque no se conecta
    state: 'RUPTURA',
    stateLabel: 'âš ï¸ Ruptura',
    type: doc.documentType,
    ...extractChainData(doc)
  })

Estados posibles en la cadena:
- 'OK': Transferencia normal y vÃ¡lida
- 'ENDOSO': Transferencia mediante endoso legal
- 'REFACTURA': RefacturaciÃ³n del vehÃ­culo
- 'RETORNO': RFC que recupera un vehÃ­culo que ya tuvo (vÃ¡lido)
- 'RUPTURA': Documento sin conexiÃ³n con la secuencia principal (problema)

PASO 7 - VALIDACIÃ“N DE RETORNOS (validateReturn):
Un retorno es vÃ¡lido cuando:
1. El RFC emisor apareciÃ³ anteriormente en rfcHistory
2. CRÃTICO: El RFC emisor NO es el poseedor actual (currentReceptorRFC). Si lo es, es continuaciÃ³n normal, NO retorno.
3. El VIN coincide con VINs de la cadena (si hay VINs disponibles)

Ejemplo de retorno vÃ¡lido: Aâ†’Bâ†’Câ†’B (B recupera el vehÃ­culo que ya tuvo)
Ejemplo de NO retorno (intermediaciÃ³n): Aâ†’Bâ†’Aâ†’C (A sigue siendo propietario, transfiere a C - es continuaciÃ³n normal)

PASO 8 - DETECCIÃ“N DE HUECOS (detectSequenceGapsAdvanced):
Analiza la cadena construida para detectar gaps:

Filtrar elementos secuenciales (position !== null)
Para cada par consecutivo (current, next):
  Si next.state === 'RETORNO': NO es gap, agregar a retornos[], continuar
  Si next.state === 'ENDOSO': NO es gap, continuar (endosos son vÃ¡lidos)
  Si current.rfcReceptor !== next.rfcEmisor Y next.state !== 'RUPTURA':
    GAP DETECTADO:
    gaps.push({
      gapPosition: "Entre posiciÃ³n {current.position} y {next.position}",
      expectedEmisor: current.rfcReceptor,
      expectedNombreEmisor: current.nombreReceptor,
      foundEmisor: next.rfcEmisor,
      foundNombreEmisor: next.nombreEmisor,
      description: "Se esperaba que {current.nombreReceptor} (RFC: {current.rfcReceptor}) fuera el emisor de la siguiente transferencia, pero se encontrÃ³ {next.nombreEmisor} (RFC: {next.rfcEmisor})",
      previousDocument: { fileId, fecha, rfcReceptor, nombreReceptor },
      nextDocument: { fileId, fecha, rfcEmisor, nombreEmisor }
    })

Documentos huÃ©rfanos (RUPTURA):
Si hay elementos con state === 'RUPTURA':
  gaps.push({
    gapPosition: 'Documentos sin conexiÃ³n',
    type: 'orphan_documents',
    description: "Se encontraron {count} documento(s) que no forman parte de la secuencia principal",
    orphanDocuments: [array de documentos huÃ©rfanos con fileId, type, fecha, rfcEmisor, nombreEmisor, rfcReceptor, nombreReceptor]
  })

Retornos vÃ¡lidos:
Para cada elemento con state === 'RETORNO':
  retornos.push({
    position: "PosiciÃ³n {item.position}",
    description: "{item.nombreReceptor} ({item.rfcReceptor}) recuperÃ³ el vehÃ­culo",
    previousOwner: elemento_anterior.nombreReceptor,
    previousRFC: elemento_anterior.rfcReceptor,
    returnedTo: item.rfcEmisor,
    returnedToName: item.nombreEmisor,
    fecha: item.fecha
  })

Retornar: { hasGaps: gaps.length > 0, hasRetornos: retornos.length > 0, gaps: [], retornos: [] }

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ESTRUCTURA DE RESPUESTA DEL ANÃLISIS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

{
  success: true,
  vin: "3GCPY9EH8LG352317",
  totalDocuments: 5,
  totalInvoices: 2,
  totalReinvoices: 2,
  totalEndorsements: 1,
  
  originDocument: {
    fileId: "uuid",
    fecha: "25/06/2020",
    rfcEmisor: "COA030402N59",
    nombreEmisor: "Car One Americana",
    rfcReceptor: "LFC1106205B4",
    nombreReceptor: "Lumo Financiera Del Centro",
    documentType: "invoice"
  },
  
  ownershipChain: [
    {
      position: 1, // null si es RUPTURA
      state: "OK" | "ENDOSO" | "REFACTURA" | "RETORNO" | "RUPTURA",
      stateLabel: "âœ“ Origen" | "ğŸ“‹ Endoso" | "ğŸ”„ Refactura" | "ğŸ”„ Retorno" | "âš ï¸ Ruptura",
      type: "invoice" | "reinvoice" | "endorsement",
      fileId: "uuid",
      documentUrl: "https://...",
      createdAt: "2025-09-26T...",
      fecha: "25/06/2020",
      numeroDocumento: "12345",
      rfcEmisor: "COA030402N59",
      nombreEmisor: "Car One Americana",
      rfcReceptor: "LFC1106205B4",
      nombreReceptor: "Lumo Financiera Del Centro",
      total: "450000.00" | null,
      usadoNuevo: "NUEVO" | "USADO" | null,
      vin: "3GCPY9EH8LG352317",
      vehiculo: {
        marca: "CHEVROLET",
        modelo: "SILVERADO DOBLE",
        ano: "2020"
      }
    }
    // ... mÃ¡s elementos
  ],
  
  sequenceAnalysis: {
    hasGaps: false,
    hasRetornos: true,
    totalGaps: 0,
    totalRetornos: 1,
    gaps: [
      {
        gapPosition: "Entre posiciÃ³n 2 y 3",
        expectedEmisor: "RFC-C",
        expectedNombreEmisor: "Persona C",
        foundEmisor: "RFC-D",
        foundNombreEmisor: "Agencia D",
        description: "Se esperaba que Persona C (RFC: RFC-C) fuera el emisor...",
        previousDocument: { fileId, fecha, rfcReceptor, nombreReceptor },
        nextDocument: { fileId, fecha, rfcEmisor, nombreEmisor }
      }
      // O para documentos huÃ©rfanos:
      {
        gapPosition: "Documentos sin conexiÃ³n",
        type: "orphan_documents",
        description: "Se encontraron 2 documento(s) sin conexiÃ³n",
        orphanDocuments: [...]
      }
    ],
    retornos: [
      {
        position: "PosiciÃ³n 4",
        description: "Lumo Financiera (RFC-B) recuperÃ³ el vehÃ­culo",
        previousOwner: "Persona A",
        previousRFC: "RFC-C",
        returnedTo: "RFC-B",
        returnedToName: "Lumo Financiera",
        fecha: "15/08/2021"
      }
    ],
    isComplete: !hasGaps
  },
  
  metadata: {
    analyzedAt: "2025-01-15T10:30:00.000Z",
    vehicleActive: true,
    createdAt: "2025-09-26T..."
  }
}

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
CASOS DE USO Y EJEMPLOS PRÃCTICOS
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

CASO 1 - Secuencia Completa Sin Huecos:
Expediente:
- Factura 1: Concesionaria (RFC-A) â†’ Financiera (RFC-B) [NUEVO]
- Factura 2: Financiera (RFC-B) â†’ Persona (RFC-C) [USADO]
- Refactura 3: Persona (RFC-C) â†’ Agencia (RFC-D) [USADO]

Resultado:
- âœ… Secuencia completa (isComplete: true)
- 0 huecos
- 0 retornos
- Cadena: Aâ†’Bâ†’Câ†’D (todas con state: 'OK' o 'REFACTURA')

CASO 2 - Secuencia con Retorno VÃ¡lido:
Expediente:
- Factura 1: Concesionaria (RFC-A) â†’ Financiera (RFC-B) [NUEVO]
- Factura 2: Financiera (RFC-B) â†’ Persona (RFC-C) [USADO]
- Refactura 3: Persona (RFC-C) â†’ Agencia (RFC-D) [USADO]
- Refactura 4: Agencia (RFC-D) â†’ Financiera (RFC-B) [USADO] â† RETORNO

Resultado:
- âœ… Secuencia completa
- 0 huecos (retornos NO son gaps)
- 1 retorno: RFC-B recupera el vehÃ­culo de RFC-D
- Cadena: Aâ†’Bâ†’Câ†’Dâ†’B (Ãºltima con state: 'RETORNO')

CASO 3 - Secuencia con Hueco:
Expediente:
- Factura 1: Concesionaria (RFC-A) â†’ Financiera (RFC-B) [NUEVO]
- Factura 2: Financiera (RFC-B) â†’ Persona (RFC-C) [USADO]
- Refactura 3: Agencia (RFC-D) â†’ Persona2 (RFC-E) [USADO] â† HUECO (falta documento donde RFC-C transfiere a RFC-D)

Resultado:
- âš ï¸ Secuencia incompleta (isComplete: false)
- 1 hueco: Entre posiciÃ³n 2 y 3
  - Se esperaba: Persona (RFC-C) como emisor
  - Se encontrÃ³: Agencia (RFC-D) como emisor
- 1 documento huÃ©rfano: Refactura 3 (state: 'RUPTURA', position: null)
- Cadena: Aâ†’B [OK], Dâ†’E [RUPTURA]

CASO 4 - Secuencia con Endoso:
Expediente:
- Factura 1: Concesionaria (RFC-A) â†’ Financiera (RFC-B) [NUEVO]
- Factura 2: Financiera (RFC-B) â†’ Persona (RFC-C) [USADO]
- Endoso 3: Persona (RFC-C) â†’ Persona2 (RFC-D) [ENDOSO]

Resultado:
- âœ… Secuencia completa
- 0 huecos (endosos NO son gaps, son transferencias vÃ¡lidas)
- Cadena: Aâ†’Bâ†’Câ†’D (posiciÃ³n 3 con state: 'ENDOSO')

CASO 5 - IntermediaciÃ³n (Edge Case CrÃ­tico):
Expediente:
- Factura 1: Concesionaria (RFC-A) â†’ Financiera (RFC-B) [NUEVO]
- Factura 2: Financiera (RFC-B) â†’ Agencia (RFC-A) [USADO] â† Agencia compra
- Refactura 3: Agencia (RFC-A) â†’ Persona (RFC-C) [USADO] â† Agencia vende

Problema potencial: La refactura 3 (Aâ†’C) podrÃ­a confundirse con retorno porque RFC-A ya apareciÃ³ antes.

SoluciÃ³n: El algoritmo valida PRIMERO isContinuation (A === currentReceptorRFC). Como A es el propietario actual, es continuaciÃ³n normal, NO retorno.

Resultado:
- âœ… Secuencia completa
- 0 huecos
- 0 retornos (correctamente identificado como continuaciÃ³n)
- Cadena: Aâ†’Bâ†’Aâ†’C (todas con state: 'OK' o 'REFACTURA')

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
NOTAS CRÃTICAS SOBRE LA LÃ“GICA
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

âš ï¸ ORDEN DE VALIDACIONES ES CRÃTICO:
En buildOwnershipChainAdvanced(), el orden de las validaciones DEBE ser:
1. PRIMERO: if (isContinuation) â†’ ContinuaciÃ³n normal
2. SEGUNDO: else if (isPotentialReturn) â†’ Retorno vÃ¡lido

NO invertir este orden. Si se invierte, casos de intermediaciÃ³n (Aâ†’Bâ†’Aâ†’C) se marcarÃ­an incorrectamente como retornos.

RazÃ³n: En intermediaciÃ³n, la tercera transferencia (Aâ†’C) cumple AMBAS condiciones:
- isContinuation = true (A es el propietario actual)
- isPotentialReturn = true (A apareciÃ³ antes)

Pero debe tratarse como continuaciÃ³n normal, por eso se valida primero isContinuation.

ğŸ”„ RETORNOS vs CONTINUACIONES:
- Retorno vÃ¡lido: RFC emisor apareciÃ³ antes Y NO es el propietario actual. Ejemplo: Aâ†’Bâ†’Câ†’B
- ContinuaciÃ³n normal: RFC emisor ES el propietario actual. Ejemplo: Aâ†’Bâ†’Aâ†’C (A sigue siendo propietario)

ğŸ“‹ ENDOSOS Y REFACTURAS:
- Endosos: NO se consideran gaps. Son transferencias vÃ¡lidas mediante endoso legal. Campos diferentes: rfc_endosante/rfc_endosatario.
- Refacturas: NO se consideran gaps. Son transferencias posteriores a la venta original. Por defecto usado_nuevo: "USADO".

ğŸ” DETECCIÃ“N DE HUECOS:
Un gap se detecta cuando:
- Entre dos documentos consecutivos en la cadena, el RFC receptor del primero NO coincide con el RFC emisor del segundo
- Y el segundo documento NO es un retorno vÃ¡lido (retornos son vÃ¡lidos, no son gaps)
- Y el segundo documento NO es un endoso (endosos son vÃ¡lidos, no son gaps)

Documentos huÃ©rfanos (RUPTURA) tambiÃ©n se consideran gaps porque no forman parte de la secuencia principal.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ENDPOINTS DE API
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Base URL: http://localhost:3000/api

POST /api/auth
Request: { email: string, password: string }
Response: { success: boolean, message: string, tokenInfo: { isValid, timeRemaining, expiresAt } }
Autentica con API Nexcar y almacena token en memoria.

POST /api/fetch-expediente
Request: { url_or_id: string } // URL de Nexcar o Vehicle ID directo
Response: { success: boolean, searchType: "expediente_completo", data: { vehicle_id, vin, total_files, invoices[], reinvoices[], other_documents[] }, raw_expediente: {} }
Extrae Vehicle ID de URL si es necesario, obtiene expediente completo de API Nexcar, almacena en currentExpediente.

POST /api/analyze-sequence
Request: {} // No requiere parÃ¡metros, usa currentExpediente en memoria
Response: Estructura completa de anÃ¡lisis (ver arriba)
Ejecuta SequenceAnalyzer.analyzeOwnershipSequence() y retorna resultados.

GET /api/token-status
Response: { success: boolean, isValid: boolean, timeRemaining: number, hasToken: boolean, expiresAt: string }
Estado del token actual.

DELETE /api/clear-token
Response: { success: boolean, message: string }
Limpia token y fuerza nueva autenticaciÃ³n.

DELETE /api/clear
Response: { success: boolean, message: string }
Limpia currentExpediente y currentDocument.

GET /api/health
Response: { success: boolean, service: string, status: string, hasExpediente: boolean, hasDocument: boolean, tokenValid: boolean, timestamp: string }
Health check del servicio.

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FRONTEND - FLUJO DE USUARIO
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

1. AutenticaciÃ³n: Usuario ingresa email/password â†’ authenticateUser() â†’ POST /api/auth â†’ Muestra estado del token.

2. BÃºsqueda: Usuario ingresa URL de Nexcar o Vehicle ID â†’ fetchExpediente() â†’ POST /api/fetch-expediente â†’ Muestra resumen con facturas, refacturas, endosos separados.

3. AnÃ¡lisis: Usuario hace clic en "Analizar Secuencia" â†’ analyzeSequence() â†’ POST /api/analyze-sequence â†’ displayAnalysisResults() muestra:
   - Resumen: VIN, total documentos, huecos, retornos
   - Documento de origen
   - Alertas de retornos (si hay)
   - Alertas de huecos con detalles (si hay)
   - Cadena completa visual con cards para cada transferencia (Emisor â†’ Receptor, badges de estado, metadatos)

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
EDGE CASES Y MANEJO DE ERRORES
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

1. Documentos sin fecha: Se ordenan al final, se intentan conectar por RFCs Ãºnicamente.

2. MÃºltiples facturas de origen: Solo se usa la primera con usado_nuevo: "NUEVO", las demÃ¡s se tratan como facturas normales.

3. VIN inconsistente: Si hay VINs diferentes en el mismo expediente â†’ ERROR, se detiene el anÃ¡lisis y se reporta inconsistencia.

4. Documentos sin OCR: Se filtran en el paso 1, no se procesan.

5. Token expirado: Se valida automÃ¡ticamente antes de cada request a API Nexcar. Si expirÃ³, se autentica automÃ¡ticamente con credenciales por defecto.

6. No se encuentra documento de origen: Retorna error "No se encontrÃ³ el documento de origen (usado_nuevo: 'NUEVO')".

7. No hay documentos fiscales: Retorna error "No se encontraron facturas ni endosos en el expediente".

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
CONFIGURACIÃ“N
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Puerto: 3000 (configurable con process.env.PORT)
API Nexcar: https://nexcar-api-770231222dff.herokuapp.com (hardcodeada en nexcarClient.js)
Credenciales: facturacion@nexcar.mx / M4u2025!! (hardcodeadas en routes.js lÃ­neas 14-15)
Dependencias: express ^4.18.2, axios ^1.6.0, cors ^2.8.5, nodemon ^3.0.1 (dev)

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
FIN DEL CONTEXTO
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Este bloque contiene TODO el contexto necesario para entender, modificar o extender el proyecto. La lÃ³gica principal estÃ¡ en src/api/sequenceAnalyzer.js, especÃ­ficamente en analyzeOwnershipSequence() que ejecuta los 8 pasos descritos arriba. El algoritmo construye la cadena de propiedad validando continuidad de RFCs (receptor de N debe ser emisor de N+1), detecta huecos cuando esta continuidad se rompe, identifica retornos vÃ¡lidos cuando un RFC recupera un vehÃ­culo que ya tuvo, y maneja endosos y refacturas como transferencias vÃ¡lidas que no se consideran gaps.

